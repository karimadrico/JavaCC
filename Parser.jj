options {
  STATIC = false;
}

PARSER_BEGIN(CobolCompiler)
import java.util.*;
import java.io.*;

public class CobolCompiler {
  // Estructura para registrar variables usadas
  private Set<String> variables = new HashSet<>();
  // Lista para almacenar el código intermedio generado
  private List<String> codigoIntermedio = new ArrayList<>();
  
  // Contadores para generación de código intermedio
  private int contadorTemporales = 1;
  private int contadorEtiquetas = 0;
  
  // Genera un nuevo nombre de variable temporal
  private String nuevaTemporal() {
    return "t" + (contadorTemporales++);
  }
  
  // Genera un nuevo nombre de etiqueta
  private String nuevaEtiqueta() {
    return "LBL" + (contadorEtiquetas++);
  }
  
  // Agrega una línea de código intermedio con indentación
  private void agregarCodigo(String codigo) {
    codigoIntermedio.add("    " + codigo);
  }
  
  // Obtiene el valor de una expresión (puede ser temporal, variable o constante)
  private String obtenerValor(String valor) {
    // Si es un número o cadena, lo devuelve tal cual
    if (valor.matches("\\d+(\\.\\d+)?([eE][+-]?\\d+)?") || 
        valor.startsWith("\"") || valor.startsWith("'")) {
      return valor;
    }
    // Si es una variable, la registra y la devuelve
    if (!valor.startsWith("t") || !valor.matches("t\\d+")) {
      variables.add(valor);
    }
    return valor;
  }

  public static void main(String[] args) throws Exception {
    System.out.println("Starting...");
    InputStream input;
    String nombreArchivo = null;
    if (args.length > 0) {
      nombreArchivo = args[0];
      input = new FileInputStream(nombreArchivo);
      System.out.println("Reading from file " + nombreArchivo + " . . .");
    } else {
      input = System.in;
      System.out.println("Reading from standard input . . .");
    }
    CobolCompiler parser = new CobolCompiler(input);
    parser.programa();
    // Imprimir código intermedio generado
    for (String linea : parser.codigoIntermedio) {
      System.out.println(linea);
    }
    System.out.println("Program parsed successfully.");
  }
}
PARSER_END(CobolCompiler)

/* -------------------- COMENTARIO COBOL línea completa (asterisco en columna 7) -------------------- */
SKIP :
{
  "\n" " " " " " " " " " " " " "*" (~["\r","\n"])*
}

/* -------------------- COMENTARIO COBOL *> -------------------- */
SKIP :
{
  < COMMENT : "*>"
    (~["\r","\n"])* >
}

/* -------------------- ESPACIOS -------------------- */
SKIP :
{
  " " | "\t" | "\r" | "\n"
}

/* -------------------- TOKENS -------------------- */
TOKEN : { < DOT: "." > }

// Palabras reservadas principales
TOKEN : { < PROGRAM: "PROGRAM" > }
TOKEN : { < BEGIN: "BEGIN" > }
TOKEN : { < END: "END" > }
TOKEN : { < ACCEPT: "ACCEPT" > }
TOKEN : { < DISPLAY: "DISPLAY" > }
TOKEN : { < MOVE: "MOVE" > }
TOKEN : { < ADD: "ADD" > }
TOKEN : { < SUBTRACT: "SUBTRACT" > }
TOKEN : { < MULTIPLY: "MULTIPLY" > }
TOKEN : { < DIVIDE: "DIVIDE" > }
TOKEN : { < GIVING: "GIVING" > }
TOKEN : { < IF: "IF" > }
TOKEN : { < THEN: "THEN" > }
TOKEN : { < ELSE: "ELSE" > }
TOKEN : { < WHILE: "WHILE" > }
TOKEN : { < DO: "DO" > }
TOKEN : { < VARYING: "VARYING" > }
TOKEN : { < FROM: "FROM" > }
TOKEN : { < TO: "TO" > }
TOKEN : { < BY: "BY" > }
TOKEN : { < IS: "IS" > }
TOKEN : { < NOT: "NOT" > }
TOKEN : { < GREATER: "GREATER" > }
TOKEN : { < LESS: "LESS" > }
TOKEN : { < EQUAL: "EQUAL" > }
TOKEN : { < THAN: "THAN" > }

// Operadores y puntuación
TOKEN : { < COMA: "," > }
TOKEN : { < MAS: "+" > }
TOKEN : { < MENOS: "-" > }
TOKEN : { < POR_OP: "*" > }
TOKEN : { < DIV_OP: "/" > }
TOKEN : { < PARENOPEN: "(" > }
TOKEN : { < PARENCLOSE: ")" > }
TOKEN : { < IGUAL_OP: "=" > }

// Identificadores, números y cadenas
TOKEN : {
  < ID:
    (["A"-"Z"])
    (["A"-"Z","0"-"9","-"])*
    (["A"-"Z","0"-"9"])
  | (["A"-"Z"])
  >
  | < NUM: (["0"-"9"])+ ("." (["0"-"9"])+)? (["e","E"] (["+","-"])? (["0"-"9"])+)? >
  | < CAD_DOBLE: "\"" (~["\""])* "\"" >
  | < CAD_SIMPLE: "'" (~["'"])* "'" >
}

/* -------------------- GRAMÁTICA -------------------- */
void programa() : {} {
  <PROGRAM> <ID> <DOT>
  <BEGIN>
  sentencias()
  <END> <DOT>
}

void sentencias() : {} {
  ( sentencia() )*
}

void sentencia() : {} {
  ( bucle() <DOT>
  | condicional() <DOT>
  | asignacion() <DOT>
  | io() <DOT>
  )
}

void bucle() : {} {
  (
    <WHILE> booleanExpr() <DO> sentencias() <END>
    |
    <VARYING> <ID> 
    (
      <FROM> atomic() <TO> atomic() (<BY> atomic() <DO> sentencias() <END> | <DO> sentencias() <END>)
      |
      <TO> atomic() (<BY> atomic() <DO> sentencias() <END> | <DO> sentencias() <END>)
    )
  )
}

void condicional() : {} {
  <IF> booleanExpr() <THEN> sentencias() (<ELSE> sentencias())? <END>
}

void asignacion() : {
  String exprResult, expr1, expr2;
  Token varId;
} {
  (
    <MOVE> exprResult=expr() <TO> varId=<ID>
    {
      variables.add(varId.image);
      agregarCodigo(varId.image + " := " + exprResult);
    }
    |
    <ADD> exprResult=expr() <TO> varId=<ID>
    {
      variables.add(varId.image);
      agregarCodigo(varId.image + " := " + varId.image + " + " + exprResult);
    }
    |
    <SUBTRACT> exprResult=expr() <FROM> varId=<ID>
    {
      variables.add(varId.image);
      agregarCodigo(varId.image + " := " + varId.image + " - " + exprResult);
    }
    |
    <MULTIPLY> expr1=expr() <BY> expr2=expr() <GIVING> varId=<ID>
    {
      variables.add(varId.image);
      agregarCodigo(varId.image + " := " + expr1 + " * " + expr2);
    }
    |
    <DIVIDE> expr1=expr() <BY> expr2=expr() <GIVING> varId=<ID>
    {
      variables.add(varId.image);
      agregarCodigo(varId.image + " := " + expr1 + " / " + expr2);
    }
  )
}

void io() : {
  Token id;
} {
  (
    <ACCEPT> id=<ID> { 
      variables.add(id.image); 
      agregarCodigo("lee " + id.image); 
    }
    |
    <DISPLAY> literal() ( <COMA> literal() )*
  )
}

void literal() : {} {
  (
    <ID> { 
      variables.add(token.image); 
      agregarCodigo("print " + token.image); 
    }
    |
    <NUM> { agregarCodigo("print " + token.image); }
    |
    <CAD_DOBLE> { agregarCodigo("print " + token.image); }
    |
    <CAD_SIMPLE> { agregarCodigo("print " + token.image); }
  )
}

String atomic() : {
  String resultado;
  Token id, num;
} {
  (
    id=<ID> { 
      variables.add(id.image); 
      resultado = id.image; 
    }
    |
    num=<NUM> { resultado = num.image; }
  )
  { return resultado; }
}

String expr() : {
  String resultado, temp, op;
} {
  resultado = mult()
  (
    (
      <MAS> { op = "+"; }
      |
      <MENOS> { op = "-"; }
    )
    temp = mult()
    {
      String nuevaTemp = nuevaTemporal();
      agregarCodigo(nuevaTemp + " := " + resultado + " " + op + " " + temp);
      resultado = nuevaTemp;
    }
  )*
  { return resultado; }
}

String mult() : {
  String resultado, temp, op;
} {
  resultado = val()
  (
    (
      <POR_OP> { op = "*"; }
      |
      <DIV_OP> { op = "/"; }
    )
    temp = val()
    {
      String nuevaTemp = nuevaTemporal();
      agregarCodigo(nuevaTemp + " := " + resultado + " " + op + " " + temp);
      resultado = nuevaTemp;
    }
  )*
  { return resultado; }
}

String val() : {
  String resultado;
  Token id, num;
} {
  (
    id=<ID> { 
      variables.add(id.image); 
      resultado = id.image; 
    }
    |
    num=<NUM> { resultado = num.image; }
    |
    <PARENOPEN> resultado=expr() <PARENCLOSE>
  )
  { return resultado; }
}

void booleanExpr() : {} {
  expr() <IS> (
    <NOT> (
      <GREATER> <THAN> expr()
      |
      <LESS> <THAN> expr()
      |
      <EQUAL> <TO> expr()
    )
    |
    <GREATER> <THAN> expr()
    |
    <LESS> <THAN> expr()
    |
    <EQUAL> <TO> expr()
  )
}