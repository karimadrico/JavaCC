options {
  STATIC = false;
}

PARSER_BEGIN(CobolCompiler)
import java.util.*;
import java.io.*;

public class CobolCompiler {
  // Estructura para registrar variables usadas
  private Set<String> variables = new HashSet<>();
  // Lista para almacenar el código intermedio generado
  private List<String> codigoIntermedio = new ArrayList<>();

  public static void main(String[] args) throws Exception {
    InputStream input;
    if (args.length > 0) {
      input = new FileInputStream(args[0]);
    } else {
      input = System.in;
    }
    CobolCompiler parser = new CobolCompiler(input);
    parser.Program();
    System.out.println("Programa analizado correctamente.\n\nVariables usadas:");
    for (String v : parser.variables) {
      System.out.println("  " + v);
    }
    System.out.println("\nCódigo intermedio generado:");
    for (String linea : parser.codigoIntermedio) {
      System.out.println(linea);
    }
  }
}
PARSER_END(CobolCompiler)

/* ====== ESPACIOS ====== */
SKIP :
{
  " " | "\t" | "\r" | "\n"
}

/* ====== COMENTARIO COBOL *> ====== */
SKIP :
{
  < COMMENT : "*>"
    (~["\r","\n"])* >
}

/* ====== TOKENS ====== */
TOKEN : { < DOT: "." > }

// Palabras reservadas principales
TOKEN : { < PROGRAM: "PROGRAM" > }
TOKEN : { < BEGIN: "BEGIN" > }
TOKEN : { < END: "END" > }
TOKEN : { < LEE: "LEE" > }
TOKEN : { < MUESTRA: "MUESTRA" > }
TOKEN : { < SUMA: "SUMA" > }
TOKEN : { < RESTA: "RESTA" > }
TOKEN : { < MULTIPLICA: "MULTIPLICA" > }
TOKEN : { < DIVIDE: "DIVIDE" > }
TOKEN : { < MUEVE: "MUEVE" > }
TOKEN : { < CALCULA: "CALCULA" > }
TOKEN : { < COMO: "COMO" > }
TOKEN : { < FIN_CALCULA: "FIN-CALCULA" > }
TOKEN : { < DE: "DE" > }
TOKEN : { < A: "A" > }
TOKEN : { < POR: "POR" > }
TOKEN : { < ENTRE: "ENTRE" > }
TOKEN : { < DANDO: "DANDO" > }
TOKEN : { < SI: "SI" > }
TOKEN : { < ENTONCES: "ENTONCES" > }
TOKEN : { < SINO: "SINO" > }
TOKEN : { < FIN_SI: "FIN-SI" > }
TOKEN : { < EJECUTA: "EJECUTA" > }
TOKEN : { < FIN_EJECUTA: "FIN-EJECUTA" > }
TOKEN : { < HASTA_QUE: "HASTA-QUE" > }
TOKEN : { < VECES: "VECES" > }
TOKEN : { < USANDO: "USANDO" > }
TOKEN : { < NO: "NO" > }
TOKEN : { < ES: "ES" > }
TOKEN : { < MAYOR: "MAYOR" > }
TOKEN : { < MENOR: "MENOR" > }
TOKEN : { < IGUAL: "IGUAL" > }
TOKEN : { < QUE: "QUE" > }

// Operadores y puntuación
TOKEN : { < COMA: "," > }
TOKEN : { < MAS: "+" > }
TOKEN : { < MENOS: "-" > }
TOKEN : { < POR_OP: "*" > }
TOKEN : { < DIV_OP: "/" > }
TOKEN : { < PARENOPEN: "(" > }
TOKEN : { < PARENCLOSE: ")" > }
TOKEN : { < IGUAL_OP: "=" > }

// Identificadores, números y cadenas
TOKEN : {
  < ID:
    (["A"-"Z"])
    (["A"-"Z","0"-"9","-"])*
    (["A"-"Z","0"-"9"])
  | (["A"-"Z"])
  >
  | < NUM: (["0"-"9"])+ >
  
}

/* ====== GRAMÁTICA ====== */
void Program() : { Token progName; } {
  <PROGRAM> progName=<ID> <DOT>
  <BEGIN>
  stmts()
  <END> <DOT>
}

void stmts() : {}
{
  ( stmt() )*
}

void stmt() : {}
{
  ( loop() <DOT>
  | cond() <DOT>
  | assig() <DOT>
  | io() <DOT>
  )
}

// Entrada y salida
void io() : {}
{
  (
    <LEE> id=<ID> { variables.add(id.image); codigoIntermedio.add("READ " + id.image); }
    |
    <MUESTRA> t1=literal() { codigoIntermedio.add("PRINT " + t1.image); }
      ( <COMA> t2=literal() { codigoIntermedio.add("PRINT " + t2.image); } )*
  )
}

// Un literal puede ser ID, NUM o cadena
void literal() : {}
{
  (
    t:<ID> { variables.add(t.image); return t; }
    |
    t:<NUM> { return t; }
  )
}

// Asignaciones: SUMA y RESTA
void assig() : {}
{
  (
    <SUMA> valor() ( valor() )* <A> <ID>
    |
    <RESTA> valor() ( valor() )* <DE> <ID>
    |
    <MULTIPLICA> valor() <POR> <ID>
    |
    <DIVIDE> valor() <ENTRE> <ID>
    |
    <MUEVE> valor() <A> <ID>
    |
    <CALCULA> <ID> ( <IGUAL_OP> valor() <FIN_CALCULA> | <COMO> valor() )
  )
}

// Un valor puede ser ID, NUM o una expresión entre paréntesis
void valor() : {}
{
  (
    t:<ID> { variables.add(t.image); return t; }
    |
    t:<NUM> { return t; }
    |
    <PARENOPEN> t=valor() <PARENCLOSE> { return t; }
  )
}

void loop() : {}
{
  (
    // Bucle tipo WHILE: EJECUTA stmts HASTA-QUE cond FIN-EJECUTA
    <EJECUTA> stmts() <HASTA_QUE> cond() <FIN_EJECUTA>
    |
    // Bucle tipo FOR: ID = NUM [A NUM [POR NUM]] VECES stmts
    <ID> <IGUAL_OP> <NUM> (<A> <NUM> (<POR> <NUM>)?)? <VECES> stmts() <FIN_EJECUTA>
  )
}

void cond() : {}
{
  // Condicional SI expr ENTONCES stmts [SINO stmts] FIN-SI
  <SI> expr() <ENTONCES> stmts() (<SINO> stmts())? <FIN_SI>
}

// Expresión booleana simple para condicionales y bucles
void expr() : {}
{
  valor() (<MAYOR>|<MENOR>|<IGUAL>) valor() ( <NO> )?
}